// Code generator: Generate phenotype.rs and physics.rs from JSON IR

use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};

use serde::Deserialize;

#[derive(Deserialize, Debug)]
struct ConfigIR {
    state_vars: Vec<String>,
    groups: HashMap<String, GroupConfig>,
    #[serde(default)]
    interactions: Vec<Interaction>,
    operations: Vec<Operation>,
}

#[derive(Deserialize, Debug)]
#[serde(tag = "kind")]
enum Interaction {
    #[serde(rename = "all_pairs_exclusion_2d")]
    AllPairsExclusion2D {
        pos: Pos2,
        radius: String,
        #[serde(default)]
        cutoff: Option<f32>,
        strength: f32,
        #[serde(default)]
        eps: Option<f32>,
        outputs: Outputs2,
    },
}

#[derive(Deserialize, Debug)]
struct Pos2 {
    x: String,
    y: String,
}

#[derive(Deserialize, Debug)]
struct Outputs2 {
    fx: String,
    fy: String,
}

#[derive(Deserialize, Debug)]
struct GroupConfig {
    activation: String,
    params: Vec<String>,
}

#[derive(Deserialize, Debug)]
struct Operation {
    target: String,
    op: String,
    #[serde(default)]
    args: Vec<String>,
    #[serde(default)]
    value: Option<f64>,
}

fn main() {
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let repo_root = manifest_dir
        .join("..")
        .join("..")
        .join("..");

    let json_path = repo_root.join("domain-model/_gen/physics_ir.json");

    if !json_path.exists() {
        eprintln!("⚠️  physics_ir.json not found. Run 'npm run build' in domain-model/ first.");
        eprintln!("   Skipping code generation.");
        return;
    }

    let json_str = fs::read_to_string(json_path).expect("Failed to read physics_ir.json");
    let ir: ConfigIR = serde_json::from_str(&json_str).expect("Invalid JSON format");

    let out_dir = repo_root.join("simulator/src/_gen");

    generate_phenotype(&ir, &out_dir);
    generate_physics(&ir, &out_dir);

    println!("✅ Generated Rust code in src/_gen/");
}

fn generate_phenotype(ir: &ConfigIR, out_dir: &Path) {
    let mut code = String::new();

    code.push_str("// AUTO-GENERATED by generate-phenotype-physics.rs - DO NOT EDIT\n\n");

    // Output struct
    code.push_str("#[allow(dead_code)]\n");
    code.push_str("pub struct PhenotypeOutput {\n");
    for name in ir.groups.keys() {
        code.push_str(&format!("    pub {}: candle_core::Tensor,\n", name));
    }
    code.push_str("}\n\n");

    // Engine struct
    code.push_str("#[allow(dead_code)]\n");
    code.push_str("pub struct PhenotypeEngine {\n");
    code.push_str("    base_net: candle_nn::Sequential,\n");
    for name in ir.groups.keys() {
        code.push_str(&format!("    head_{}: candle_nn::Linear,\n", name));
    }
    code.push_str("}\n\n");

    // Implementation
    code.push_str("impl PhenotypeEngine {\n");

    // new function
    code.push_str("    #[allow(dead_code)]\n");
    code.push_str(
        "    pub fn new(vs: candle_nn::VarBuilder, input_dim: usize, hidden_dim: usize) -> candle_core::Result<Self> {\n",
    );
    code.push_str("        let base_net = candle_nn::seq()\n");
    code.push_str(
        "            .add(candle_nn::linear(input_dim, hidden_dim, vs.pp(\"base1\"))?)\n",
    );
    code.push_str("            .add(candle_nn::Activation::Relu);\n\n");

    for (name, data) in &ir.groups {
        let size = data.params.len();
        code.push_str(&format!(
            "        let head_{} = candle_nn::linear(hidden_dim, {}, vs.pp(\"head_{}\"))?;\n",
            name, size, name
        ));
    }

    code.push_str("\n        Ok(Self {\n");
    code.push_str("            base_net,\n");
    for name in ir.groups.keys() {
        code.push_str(&format!("            head_{},\n", name));
    }
    code.push_str("        })\n");
    code.push_str("    }\n\n");

    // forward function
    code.push_str("    #[allow(dead_code)]\n");
    code.push_str("    pub fn forward(&self, genes: &candle_core::Tensor) -> candle_core::Result<PhenotypeOutput> {\n");
    code.push_str("        let latent = candle_nn::Module::forward(&self.base_net, genes)?;\n\n");

    for (name, data) in &ir.groups {
        code.push_str(&format!(
            "        let raw_{} = candle_nn::Module::forward(&self.head_{}, &latent)?;\n",
            name, name
        ));

        let activation_code = match data.activation.as_str() {
            "softmax" => format!("candle_nn::ops::softmax(&raw_{}, 1)?", name),
            "tanh" => format!("raw_{}.tanh()?", name),
            "sigmoid" => format!("candle_nn::ops::sigmoid(&raw_{})?", name),
            _ => format!("raw_{}", name),
        };

        code.push_str(&format!(
            "        let val_{} = {};\n",
            name, activation_code
        ));
    }

    code.push_str("\n        Ok(PhenotypeOutput {\n");
    for name in ir.groups.keys() {
        code.push_str(&format!("            {}: val_{},\n", name, name));
    }
    code.push_str("        })\n");
    code.push_str("    }\n");
    code.push_str("}\n");

    fs::write(out_dir.join("phenotype.rs"), code).expect("Failed to write phenotype.rs");
}

fn generate_physics(ir: &ConfigIR, out_dir: &Path) {
    let mut code = String::new();

    code.push_str("// AUTO-GENERATED by generate-phenotype-physics.rs - DO NOT EDIT\n\n");

    // Export state metadata for the simulator.
    code.push_str(&format!("pub const STATE_DIMS: usize = {};\n", ir.state_vars.len()));
    code.push_str(&format!("pub const STATE_VARS: [&str; {}] = [\n", ir.state_vars.len()));
    for name in &ir.state_vars {
        code.push_str(&format!("    \"{}\",\n", name));
    }
    code.push_str("];\n\n");

    // Function signature
    code.push_str("#[allow(dead_code)]\n");
    code.push_str("pub fn update_physics(\n");
    code.push_str("    state: &candle_core::Tensor,\n");
    for name in ir.groups.keys() {
        code.push_str(&format!("    p_{}: &candle_core::Tensor,\n", name));
    }
    code.push_str(") -> candle_core::Result<candle_core::Tensor> {\n");
    // Decompose state variables
    code.push_str("    // State variable decomposition\n");
    for (i, name) in ir.state_vars.iter().enumerate() {
        code.push_str(&format!(
            "    let s_{} = state.narrow(1, {}, 1)?;\n",
            name, i
        ));
    }
    code.push('\n');

    // Interactions
    if !ir.interactions.is_empty() {
        code.push_str("    // Interactions (stage-A may be O(N^2))\n");
        for interaction in &ir.interactions {
            match interaction {
                Interaction::AllPairsExclusion2D {
                    pos,
                    radius,
                    cutoff,
                    strength,
                    eps,
                    outputs,
                } => {
                    let idx_x = ir
                        .state_vars
                        .iter()
                        .position(|s| s == &pos.x)
                        .expect("pos.x not found in state_vars");
                    let idx_y = ir
                        .state_vars
                        .iter()
                        .position(|s| s == &pos.y)
                        .expect("pos.y not found in state_vars");
                    let idx_r = ir
                        .state_vars
                        .iter()
                        .position(|s| s == radius)
                        .expect("radius not found in state_vars");

                    let eps_val = eps.unwrap_or(1e-4);
                    let cutoff2 = cutoff.map(|c| c * c);

                    code.push_str(&format!(
                        "    // all_pairs_exclusion_2d: outputs {} / {}\n",
                        outputs.fx, outputs.fy
                    ));
                    code.push_str("    let state_host: Vec<Vec<f32>> = state.to_vec2()?;\n");
                    code.push_str("    let n_agents = state_host.len();\n");
                    code.push_str("    let mut fx = vec![0f32; n_agents];\n");
                    code.push_str("    let mut fy = vec![0f32; n_agents];\n");
                    code.push_str("    for i in 0..n_agents {\n");
                    code.push_str("        let xi = state_host[i][");
                    code.push_str(&format!("{}", idx_x));
                    code.push_str("];\n");
                    code.push_str("        let yi = state_host[i][");
                    code.push_str(&format!("{}", idx_y));
                    code.push_str("];\n");
                    code.push_str("        let ri = state_host[i][");
                    code.push_str(&format!("{}", idx_r));
                    code.push_str("];\n");
                    code.push_str("        for j in (i + 1)..n_agents {\n");
                    code.push_str("            let xj = state_host[j][");
                    code.push_str(&format!("{}", idx_x));
                    code.push_str("];\n");
                    code.push_str("            let yj = state_host[j][");
                    code.push_str(&format!("{}", idx_y));
                    code.push_str("];\n");
                    code.push_str("            let rj = state_host[j][");
                    code.push_str(&format!("{}", idx_r));
                    code.push_str("];\n");
                    code.push_str("            let dx = xi - xj;\n");
                    code.push_str("            let dy = yi - yj;\n");
                    code.push_str(&format!("            let d2 = dx * dx + dy * dy + {}f32;\n", eps_val));
                    if let Some(c2) = cutoff2 {
                        code.push_str(&format!(
                            "            if d2 > {}f32 {{ continue; }}\n",
                            c2
                        ));
                    }
                    code.push_str("            let r = ri + rj;\n");
                    code.push_str("            let delta = r * r - d2;\n");
                    code.push_str("            if delta <= 0f32 { continue; }\n");
                    code.push_str(&format!(
                        "            let inv = 1.0f32 / d2;\n            let m = {}f32 * delta * inv;\n",
                        strength
                    ));
                    code.push_str("            let fx_ij = m * dx;\n");
                    code.push_str("            let fy_ij = m * dy;\n");
                    code.push_str("            fx[i] += fx_ij;\n");
                    code.push_str("            fy[i] += fy_ij;\n");
                    code.push_str("            fx[j] -= fx_ij;\n");
                    code.push_str("            fy[j] -= fy_ij;\n");
                    code.push_str("        }\n");
                    code.push_str("    }\n");
                    code.push_str(&format!(
                        "    let {} = candle_core::Tensor::from_vec(fx, (n_agents, 1), state.device())?;\n",
                        outputs.fx
                    ));
                    code.push_str(&format!(
                        "    let {} = candle_core::Tensor::from_vec(fy, (n_agents, 1), state.device())?;\n\n",
                        outputs.fy
                    ));
                }
            }
        }
    }

    // Decompose parameters
    code.push_str("    // Parameter decomposition\n");
    for (g_name, g_data) in &ir.groups {
        for (i, p_name) in g_data.params.iter().enumerate() {
            code.push_str(&format!(
                "    let p_{} = p_{}.narrow(1, {}, 1)?;\n",
                p_name, g_name, i
            ));
        }
    }
    code.push('\n');

    // Operations
    code.push_str("    // Physics operations\n");
    for op in &ir.operations {
        let expr = match op.op.as_str() {
            "const" => {
                if let Some(val) = op.value {
                    format!("candle_core::Tensor::new(&[{}f32], state.device())?", val)
                } else {
                    "candle_core::Tensor::new(&[0f32], state.device())?".to_string()
                }
            }
            "ref_param" => {
                // Already decomposed above
                continue;
            }
            "add" if op.args.len() == 2 => {
                format!("{}.broadcast_add(&{})?", op.args[0], op.args[1])
            }
            "sub" if op.args.len() == 2 => {
                format!("{}.broadcast_sub(&{})?", op.args[0], op.args[1])
            }
            "mul" if op.args.len() == 2 => {
                format!("{}.broadcast_mul(&{})?", op.args[0], op.args[1])
            }
            "div" if op.args.len() == 2 => {
                format!("{}.broadcast_div(&{})?", op.args[0], op.args[1])
            }
            "relu" if op.args.len() == 1 => {
                format!("{}.relu()?", op.args[0])
            }
            "neg" if op.args.len() == 1 => {
                format!("{}.neg()?", op.args[0])
            }
            "add" if op.args.len() == 1 => {
                // Assignment operation (final state update)
                op.args[0].to_string()
            }
            _ => {
                eprintln!("⚠️  Unknown operation: {:?}", op);
                "candle_core::Tensor::new(&[0f32], state.device())?".to_string()
            }
        };

        code.push_str(&format!("    let {} = {};\n", op.target, expr));
    }

    code.push_str("\n    // Concatenate updated state\n");
    code.push_str("    candle_core::Tensor::cat(&[\n");
    for name in &ir.state_vars {
        code.push_str(&format!("        &{},\n", name));
    }
    code.push_str("    ], 1)\n");
    code.push_str("}\n");

    fs::write(out_dir.join("physics.rs"), code).expect("Failed to write physics.rs");
}
