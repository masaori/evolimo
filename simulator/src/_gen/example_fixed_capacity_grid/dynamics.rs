// AUTO-GENERATED by generate-phenotype-physics.rs - DO NOT EDIT

pub const N_AGENTS: usize = 10;
pub const GENE_LEN: usize = 32;
pub const HIDDEN_LEN: usize = 64;

use crate::grid::{SpatialGrid, particles_to_grid, grid_to_particles};

pub const GRID_CONFIG: SpatialGrid = SpatialGrid {
    width: 80,
    height: 64,
    capacity: 8,
    cell_size: (128.000000, 125.000000),
};

pub const STATE_DIMS: usize = 5;
pub const STATE_VARS: [&str; 5] = [
    "pos_x",
    "pos_y",
    "vel_x",
    "vel_y",
    "size",
];

#[allow(dead_code)]
pub fn init_state(
    n_agents: usize,
    device: &candle_core::Device,
) -> candle_core::Result<candle_core::Tensor> {
    let init_pos_x = candle_core::Tensor::rand(0f32, 10240f32, (n_agents, 1), device)?;
    let init_pos_y = candle_core::Tensor::rand(0f32, 8000f32, (n_agents, 1), device)?;
    let init_vel_x = candle_core::Tensor::randn(0f32, 1f32, (n_agents, 1), device)?;
    let init_vel_y = candle_core::Tensor::randn(0f32, 1f32, (n_agents, 1), device)?;
    let init_size = candle_core::Tensor::new(&[5f32], device)?.broadcast_as((n_agents, 1))?;

    candle_core::Tensor::cat(&[
        &init_pos_x,
        &init_pos_y,
        &init_vel_x,
        &init_vel_y,
        &init_size,
    ], 1)
}

#[allow(dead_code)]
#[allow(unused_variables)]
pub fn update_dynamics(
    state: &candle_core::Tensor,
    p_physics: &candle_core::Tensor,
    p_attributes: &candle_core::Tensor,
) -> candle_core::Result<candle_core::Tensor> {
    // State variable decomposition
    let s_pos_x = state.narrow(1, 0, 1)?;
    let s_pos_y = state.narrow(1, 1, 1)?;
    let s_vel_x = state.narrow(1, 2, 1)?;
    let s_vel_y = state.narrow(1, 3, 1)?;
    let s_size = state.narrow(1, 4, 1)?;

    // Parameter decomposition
    let p_grav_g = p_physics.narrow(1, 0, 1)?;
    let p_dummy_attr = p_attributes.narrow(1, 0, 1)?;

    #[allow(unused_assignments)]
    let mut temp_6_indices: candle_core::Tensor = candle_core::Tensor::zeros(1, candle_core::DType::U32, state.device())?;

    // Internal dynamics operations
    let temp_0 = candle_core::Tensor::new(&[0.1f32], state.device())?;
    let temp_1 = s_vel_x.broadcast_mul(&temp_0)?;
    let temp_2 = s_pos_x.broadcast_add(&temp_1)?;
    let pos_x = temp_2;
    let temp_3 = s_vel_y.broadcast_mul(&temp_0)?;
    let temp_4 = s_pos_y.broadcast_add(&temp_3)?;
    let pos_y = temp_4;
    let temp_5 = candle_core::Tensor::cat(&[&s_pos_x, &s_pos_y, &s_vel_x, &s_vel_y, &s_size], 1)?;
    let temp_6 = {
                    let (grid, _mask, indices) = particles_to_grid(&s_pos_x, &s_pos_y, &temp_5, &GRID_CONFIG)?;
                    temp_6_indices = indices;
                    grid
                };
    let temp_7 = {
        let grid = &temp_6;
        let range = 1;
        let (h, w, cap, d) = grid.dims4()?;
        let pad = range as usize;
        let padded = crate::grid::create_torus_padded_grid(grid, pad)?;
        let mut acc = grid.zeros_like()?;
        for dy in -range..=range {
            for dx in -range..=range {
                let offset_y = (pad as i32 + dy) as usize;
                let offset_x = (pad as i32 + dx) as usize;
                let neighbor = padded.narrow(0, offset_y, h)?.narrow(1, offset_x, w)?;
                let center = grid;
                let temp_0 = center.narrow(3, 0, 1)?;
                let temp_1 = candle_core::Tensor::new(&[0f32], state.device())?;
                let temp_2 = temp_0.broadcast_mul(&temp_1)?;
                let temp_3 = neighbor.narrow(3, 4, 1)?;
                let temp_4 = temp_3.transpose(2, 3)?;
                let temp_5 = neighbor.narrow(3, 0, 1)?;
                let temp_6 = temp_5.transpose(2, 3)?;
                let temp_7 = temp_6.broadcast_sub(&temp_0)?;
                let temp_8 = temp_4.broadcast_mul(&temp_7)?;
                let temp_9 = candle_core::Tensor::new(&[1f32], state.device())?;
                let temp_10 = temp_7.broadcast_mul(&temp_7)?;
                let temp_11 = neighbor.narrow(3, 1, 1)?;
                let temp_12 = temp_11.transpose(2, 3)?;
                let temp_13 = center.narrow(3, 1, 1)?;
                let temp_14 = temp_12.broadcast_sub(&temp_13)?;
                let temp_15 = temp_14.broadcast_mul(&temp_14)?;
                let temp_16 = temp_10.broadcast_add(&temp_15)?;
                let temp_17 = candle_core::Tensor::new(&[0.01f32], state.device())?;
                let temp_18 = temp_16.broadcast_add(&temp_17)?;
                let temp_19 = temp_9.broadcast_div(&temp_18)?;
                let temp_20 = temp_8.broadcast_mul(&temp_19)?;
                let temp_21 = temp_20.sum_keepdim(3)?;
                let temp_22 = temp_4.broadcast_mul(&temp_14)?;
                let temp_23 = temp_22.broadcast_mul(&temp_19)?;
                let temp_24 = temp_23.sum_keepdim(3)?;
                let temp_25 = candle_core::Tensor::cat(&[&temp_2, &temp_2, &temp_21, &temp_24, &temp_2], 3)?;
                let kernel_output = temp_25;
                acc = acc.add(&kernel_output)?;
            }
        }
        acc
    };
    let temp_8 = grid_to_particles(&temp_7, &temp_6_indices)?;
    let temp_9 = temp_8.narrow(1, 2, 1)?;
    let temp_10 = candle_core::Tensor::new(&[0f32], state.device())?;
    let temp_11 = p_grav_g.broadcast_mul(&temp_10)?;
    let temp_12 = p_dummy_attr.broadcast_mul(&temp_10)?;
    let temp_13 = temp_11.broadcast_add(&temp_12)?;
    let temp_14 = temp_9.broadcast_add(&temp_13)?;
    let temp_15 = temp_14.broadcast_mul(&temp_0)?;
    let temp_16 = s_vel_x.broadcast_add(&temp_15)?;
    let vel_x = temp_16;
    let temp_17 = temp_8.narrow(1, 3, 1)?;
    let temp_18 = temp_17.broadcast_mul(&temp_0)?;
    let temp_19 = s_vel_y.broadcast_add(&temp_18)?;
    let vel_y = temp_19;
    let size = s_size;

    // Boundary conditions
    // torus wrap: pos_x in [0.000000,10240.000000]
    let pos_x = {
        let min = candle_core::Tensor::new(&[0.000000f32], state.device())?;
        let width = candle_core::Tensor::new(&[10240.000000f32], state.device())?;
        let norm = pos_x.broadcast_sub(&min)?;
        let div = norm.broadcast_div(&width)?;
        let floor = div.floor()?;
        let term = floor.broadcast_mul(&width)?;
        let rem = norm.broadcast_sub(&term)?;
        rem.broadcast_add(&min)?
    };
    // torus wrap: pos_y in [0.000000,8000.000000]
    let pos_y = {
        let min = candle_core::Tensor::new(&[0.000000f32], state.device())?;
        let width = candle_core::Tensor::new(&[8000.000000f32], state.device())?;
        let norm = pos_y.broadcast_sub(&min)?;
        let div = norm.broadcast_div(&width)?;
        let floor = div.floor()?;
        let term = floor.broadcast_mul(&width)?;
        let rem = norm.broadcast_sub(&term)?;
        rem.broadcast_add(&min)?
    };

    // Concatenate updated state
    let n_agents = state.dim(0)?;
    candle_core::Tensor::cat(&[
        &pos_x.broadcast_as((n_agents, 1))?,
        &pos_y.broadcast_as((n_agents, 1))?,
        &vel_x.broadcast_as((n_agents, 1))?,
        &vel_y.broadcast_as((n_agents, 1))?,
        &size.broadcast_as((n_agents, 1))?,
    ], 1)
}
