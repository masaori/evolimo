// AUTO-GENERATED by generate-phenotype-physics.rs - DO NOT EDIT

#[allow(dead_code)]
pub struct PhenotypeOutput {
    pub physics: candle_core::Tensor,
    pub attributes: candle_core::Tensor,
}

#[allow(dead_code)]
pub struct PhenotypeEngine {
    base_net: candle_nn::Sequential,
    head_physics: candle_nn::Linear,
    head_attributes: candle_nn::Linear,
}

impl PhenotypeEngine {
    #[allow(dead_code)]
    pub fn new(vs: candle_nn::VarBuilder, input_dim: usize, hidden_dim: usize) -> candle_core::Result<Self> {
        let base_net = candle_nn::seq()
            .add(candle_nn::linear(input_dim, hidden_dim, vs.pp("base1"))?)
            .add(candle_nn::Activation::Relu);

        let head_physics = candle_nn::linear(hidden_dim, 1, vs.pp("head_physics"))?;
        let head_attributes = candle_nn::linear(hidden_dim, 1, vs.pp("head_attributes"))?;

        Ok(Self {
            base_net,
            head_physics,
            head_attributes,
        })
    }

    #[allow(dead_code)]
    pub fn forward(&self, genes: &candle_core::Tensor) -> candle_core::Result<PhenotypeOutput> {
        let latent = candle_nn::Module::forward(&self.base_net, genes)?;

        let raw_physics = candle_nn::Module::forward(&self.head_physics, &latent)?;
        let val_physics = raw_physics.tanh()?;
        let raw_attributes = candle_nn::Module::forward(&self.head_attributes, &latent)?;
        let val_attributes = candle_nn::ops::softmax(&raw_attributes, 1)?;

        Ok(PhenotypeOutput {
            physics: val_physics,
            attributes: val_attributes,
        })
    }
}

#[allow(dead_code)]
pub fn init_genes(
    n_agents: usize,
    gene_len: usize,
    device: &candle_core::Device,
) -> candle_core::Result<candle_core::Tensor> {
    candle_core::Tensor::randn(0f32, 1f32, (n_agents, gene_len), device)
}
