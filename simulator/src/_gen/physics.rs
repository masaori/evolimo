// AUTO-GENERATED by generate-phenotype-physics.rs - DO NOT EDIT

pub const STATE_DIMS: usize = 6;
pub const STATE_VARS: [&str; 6] = [
    "pos_x",
    "pos_y",
    "vel_x",
    "vel_y",
    "size",
    "energy",
];

#[allow(dead_code)]
pub fn init_state(
    n_agents: usize,
    device: &candle_core::Device,
) -> candle_core::Result<candle_core::Tensor> {
    let init_pos_x = candle_core::Tensor::rand(-512f32, 512f32, (n_agents, 1), device)?;
    let init_pos_y = candle_core::Tensor::rand(-400f32, 400f32, (n_agents, 1), device)?;
    let init_vel_x = candle_core::Tensor::new(&[0f32], device)?.broadcast_as((n_agents, 1))?;
    let init_vel_y = candle_core::Tensor::new(&[0f32], device)?.broadcast_as((n_agents, 1))?;
    let init_size = candle_core::Tensor::new(&[1f32], device)?.broadcast_as((n_agents, 1))?;
    let init_energy = candle_core::Tensor::new(&[0f32], device)?.broadcast_as((n_agents, 1))?;

    candle_core::Tensor::cat(&[
        &init_pos_x,
        &init_pos_y,
        &init_vel_x,
        &init_vel_y,
        &init_size,
        &init_energy,
    ], 1)
}

#[allow(dead_code)]
pub fn update_physics(
    state: &candle_core::Tensor,
    p_physics: &candle_core::Tensor,
    p_attributes: &candle_core::Tensor,
) -> candle_core::Result<candle_core::Tensor> {
    // State variable decomposition
    let s_pos_x = state.narrow(1, 0, 1)?;
    let s_pos_y = state.narrow(1, 1, 1)?;
    let s_vel_x = state.narrow(1, 2, 1)?;
    let s_vel_y = state.narrow(1, 3, 1)?;
    let s_size = state.narrow(1, 4, 1)?;
    let s_energy = state.narrow(1, 5, 1)?;

    // Interactions (stage-A may be O(N^2))
    // Torus X: pos_x in [-512.000000,512.000000] (width=1024.000000)
    let torus_x_width = 1024.000000f32;
    let torus_x_half = 512.000000f32;
    // Torus Y: pos_y in [-400.000000,400.000000] (width=800.000000)
    let torus_y_width = 800.000000f32;
    let torus_y_half = 400.000000f32;
    // all_pairs_exclusion_2d: outputs f_excl_x / f_excl_y
    let state_host: Vec<Vec<f32>> = state.to_vec2()?;
    let n_agents = state_host.len();
    let mut fx = vec![0f32; n_agents];
    let mut fy = vec![0f32; n_agents];
    for i in 0..n_agents {
        let xi = state_host[i][0];
        let yi = state_host[i][1];
        let ri = state_host[i][4];
        for j in (i + 1)..n_agents {
            let xj = state_host[j][0];
            let yj = state_host[j][1];
            let rj = state_host[j][4];
            let mut dx = xi - xj;
            dx = (dx + torus_x_half).rem_euclid(torus_x_width) - torus_x_half;
            let mut dy = yi - yj;
            dy = (dy + torus_y_half).rem_euclid(torus_y_width) - torus_y_half;
            let d2 = dx * dx + dy * dy + 0.0001f32;
            if d2 > 2500f32 { continue; }
            let r = ri + rj;
            let delta = r * r - d2;
            if delta <= 0f32 { continue; }
            let inv = 1.0f32 / d2;
            let m = 5f32 * delta * inv;
            let fx_ij = m * dx;
            let fy_ij = m * dy;
            fx[i] += fx_ij;
            fy[i] += fy_ij;
            fx[j] -= fx_ij;
            fy[j] -= fy_ij;
        }
    }
    let f_excl_x = candle_core::Tensor::from_vec(fx, (n_agents, 1), state.device())?;
    let f_excl_y = candle_core::Tensor::from_vec(fy, (n_agents, 1), state.device())?;

    // Parameter decomposition
    let p_drag_coeff = p_physics.narrow(1, 0, 1)?;
    let p_metabolism = p_attributes.narrow(1, 0, 1)?;

    // Physics operations
    let temp_0 = candle_core::Tensor::new(&[0.1f32], state.device())?;
    let temp_1 = f_excl_x.broadcast_mul(&temp_0)?;
    let temp_2 = s_vel_x.broadcast_add(&temp_1)?;
    let temp_3 = s_vel_x.broadcast_mul(&p_drag_coeff)?;
    let temp_4 = temp_3.broadcast_mul(&temp_0)?;
    let temp_5 = temp_2.broadcast_sub(&temp_4)?;
    let vel_x = temp_5;
    let temp_6 = f_excl_y.broadcast_mul(&temp_0)?;
    let temp_7 = s_vel_y.broadcast_add(&temp_6)?;
    let temp_8 = s_vel_y.broadcast_mul(&p_drag_coeff)?;
    let temp_9 = temp_8.broadcast_mul(&temp_0)?;
    let temp_10 = temp_7.broadcast_sub(&temp_9)?;
    let vel_y = temp_10;
    let temp_11 = s_vel_x.broadcast_mul(&temp_0)?;
    let temp_12 = s_pos_x.broadcast_add(&temp_11)?;
    let pos_x = temp_12;
    let temp_13 = s_vel_y.broadcast_mul(&temp_0)?;
    let temp_14 = s_pos_y.broadcast_add(&temp_13)?;
    let pos_y = temp_14;
    let temp_15 = p_metabolism.broadcast_mul(&temp_0)?;
    let temp_16 = s_energy.broadcast_sub(&temp_15)?;
    let energy = temp_16;
    let size = s_size;

    // Boundary conditions
    let n_agents = state.dims()[0];
    // torus wrap: pos_x in [-512.000000,512.000000]
    let mut _bc_col = pos_x.to_vec2::<f32>()?;
    let mut _bc_flat: Vec<f32> = _bc_col.into_iter().map(|r| r[0]).collect();
    for v in _bc_flat.iter_mut() { *v = (*v - (-512.000000f32)).rem_euclid(1024.000000f32) + (-512.000000f32); }
    let pos_x = candle_core::Tensor::from_vec(_bc_flat, (n_agents, 1), state.device())?;
    // torus wrap: pos_y in [-400.000000,400.000000]
    let mut _bc_col = pos_y.to_vec2::<f32>()?;
    let mut _bc_flat: Vec<f32> = _bc_col.into_iter().map(|r| r[0]).collect();
    for v in _bc_flat.iter_mut() { *v = (*v - (-400.000000f32)).rem_euclid(800.000000f32) + (-400.000000f32); }
    let pos_y = candle_core::Tensor::from_vec(_bc_flat, (n_agents, 1), state.device())?;

    // Concatenate updated state
    candle_core::Tensor::cat(&[
        &pos_x,
        &pos_y,
        &vel_x,
        &vel_y,
        &size,
        &energy,
    ], 1)
}

#[allow(dead_code)]
pub fn update_physics_cpu(
    state: &[f32],
    p_physics: &[f32],
    p_attributes: &[f32],
) -> candle_core::Result<Vec<f32>> {
    let n_agents = state.len() / STATE_DIMS;
    let mut out = vec![0f32; n_agents * STATE_DIMS];

    let stride_physics = if n_agents == 0 { 0 } else { p_physics.len() / n_agents };
    let stride_attributes = if n_agents == 0 { 0 } else { p_attributes.len() / n_agents };

    // Interactions (CPU cell-list)
    let min_x = -512.000000f32;
    let max_x = 512.000000f32;
    let min_y = -400.000000f32;
    let max_y = 400.000000f32;
    let use_torus_x = true;
    let use_torus_y = true;
    let world_w = max_x - min_x;
    let world_h = max_y - min_y;
    let half_w = world_w * 0.5;
    let half_h = world_h * 0.5;
    // all_pairs_exclusion_2d (CPU): outputs f_excl_x / f_excl_y
    let mut aux_f_excl_x = vec![0f32; n_agents];
    let mut aux_f_excl_y = vec![0f32; n_agents];
    let mut _x = vec![0f32; n_agents];
    let mut _y = vec![0f32; n_agents];
    let mut _r = vec![0f32; n_agents];
    let mut _max_r = 0f32;
    for i in 0..n_agents {
        let base = i * STATE_DIMS;
        let xi = state[base + 0];
        let yi = state[base + 1];
        let ri = state[base + 4];
        _x[i] = xi;
        _y[i] = yi;
        _r[i] = ri;
        if ri > _max_r { _max_r = ri; }
    }
    let mut _range = 50.000000f32;
    let _pair_max = 2.0f32 * _max_r;
    if _pair_max < _range { _range = _pair_max; }
    let cell_size = _range.max(1e-3f32);
    let grid_w = ((world_w / cell_size).ceil() as isize).max(1);
    let grid_h = ((world_h / cell_size).ceil() as isize).max(1);
    let n_cells = (grid_w * grid_h) as usize;
    let mut head = vec![usize::MAX; n_cells];
    let mut next = vec![usize::MAX; n_agents];
    for i in 0..n_agents {
        let mut cx = ((_x[i] - min_x) / cell_size).floor() as isize;
        let mut cy = ((_y[i] - min_y) / cell_size).floor() as isize;
        if use_torus_x { cx = cx.rem_euclid(grid_w); } else { cx = cx.clamp(0, grid_w - 1); }
        if use_torus_y { cy = cy.rem_euclid(grid_h); } else { cy = cy.clamp(0, grid_h - 1); }
        let cell = (cx + cy * grid_w) as usize;
        next[i] = head[cell];
        head[cell] = i;
    }
    let cutoff2 = cell_size * cell_size;
    for cy in 0..grid_h {
        for cx in 0..grid_w {
            let cell = (cx + cy * grid_w) as usize;
            let mut i_opt = head[cell];
            while i_opt != usize::MAX {
                let i = i_opt;
                // Same cell pairs (j>i)
                let mut j_opt = next[i];
                while j_opt != usize::MAX {
                    let j = j_opt;
                    j_opt = next[j];
                    let mut dx = _x[i] - _x[j];
                    if use_torus_x { dx = (dx + half_w).rem_euclid(world_w) - half_w; }
                    let mut dy = _y[i] - _y[j];
                    if use_torus_y { dy = (dy + half_h).rem_euclid(world_h) - half_h; }
                    let d2 = dx * dx + dy * dy + 0.000100f32;
                    if d2 > cutoff2 { continue; }
                    let rsum = _r[i] + _r[j];
                    let delta = rsum * rsum - d2;
                    if delta <= 0f32 { continue; }
                    let inv = 1.0f32 / d2;
                    let m = 5.000000f32 * delta * inv;
                    let fx_ij = m * dx;
                    let fy_ij = m * dy;
                    aux_f_excl_x[i] += fx_ij;
                    aux_f_excl_y[i] += fy_ij;
                    aux_f_excl_x[j] -= fx_ij;
                    aux_f_excl_y[j] -= fy_ij;
                }

                // Neighbor cells (avoid double counting by only visiting (dx,dy) where neighbor cell id > cell id)
                for oy in -1..=1 {
                    for ox in -1..=1 {
                        if ox == 0 && oy == 0 { continue; }
                        let mut ncx = cx + ox;
                        let mut ncy = cy + oy;
                        if use_torus_x { ncx = ncx.rem_euclid(grid_w); }
                        if use_torus_y { ncy = ncy.rem_euclid(grid_h); }
                        if !use_torus_x && (ncx < 0 || ncx >= grid_w) { continue; }
                        if !use_torus_y && (ncy < 0 || ncy >= grid_h) { continue; }
                        let ncell = (ncx + ncy * grid_w) as usize;
                        if ncell <= cell { continue; }
                        let mut j2_opt = head[ncell];
                        while j2_opt != usize::MAX {
                            let j = j2_opt;
                            j2_opt = next[j];
                            let mut dx = _x[i] - _x[j];
                            if use_torus_x { dx = (dx + half_w).rem_euclid(world_w) - half_w; }
                            let mut dy = _y[i] - _y[j];
                            if use_torus_y { dy = (dy + half_h).rem_euclid(world_h) - half_h; }
                            let d2 = dx * dx + dy * dy + 0.000100f32;
                            if d2 > cutoff2 { continue; }
                            let rsum = _r[i] + _r[j];
                            let delta = rsum * rsum - d2;
                            if delta <= 0f32 { continue; }
                            let inv = 1.0f32 / d2;
                            let m = 5.000000f32 * delta * inv;
                            let fx_ij = m * dx;
                            let fy_ij = m * dy;
                            aux_f_excl_x[i] += fx_ij;
                            aux_f_excl_y[i] += fy_ij;
                            aux_f_excl_x[j] -= fx_ij;
                            aux_f_excl_y[j] -= fy_ij;
                        }
                    }
                }

                i_opt = next[i];
            }
        }
    }

    for i in 0..n_agents {
        let base = i * STATE_DIMS;
        let s_pos_x = state[base + 0];
        let s_pos_y = state[base + 1];
        let s_vel_x = state[base + 2];
        let s_vel_y = state[base + 3];
        let s_size = state[base + 4];
        let s_energy = state[base + 5];
        let f_excl_x = aux_f_excl_x[i];
        let f_excl_y = aux_f_excl_y[i];
        let p_drag_coeff = p_physics[i * stride_physics + 0];
        let p_metabolism = p_attributes[i * stride_attributes + 0];

        let temp_0 = 0.1f32;
        let temp_1 = f_excl_x * temp_0;
        let temp_2 = s_vel_x + temp_1;
        let temp_3 = s_vel_x * p_drag_coeff;
        let temp_4 = temp_3 * temp_0;
        let temp_5 = temp_2 - temp_4;
        let vel_x = temp_5;
        let temp_6 = f_excl_y * temp_0;
        let temp_7 = s_vel_y + temp_6;
        let temp_8 = s_vel_y * p_drag_coeff;
        let temp_9 = temp_8 * temp_0;
        let temp_10 = temp_7 - temp_9;
        let vel_y = temp_10;
        let temp_11 = s_vel_x * temp_0;
        let temp_12 = s_pos_x + temp_11;
        let pos_x = temp_12;
        let temp_13 = s_vel_y * temp_0;
        let temp_14 = s_pos_y + temp_13;
        let pos_y = temp_14;
        let temp_15 = p_metabolism * temp_0;
        let temp_16 = s_energy - temp_15;
        let energy = temp_16;
        let size = s_size;
        let pos_x = (pos_x - (-512.000000f32)).rem_euclid(1024.000000f32) + (-512.000000f32);
        let pos_y = (pos_y - (-400.000000f32)).rem_euclid(800.000000f32) + (-400.000000f32);
        out[base + 0] = pos_x;
        out[base + 1] = pos_y;
        out[base + 2] = vel_x;
        out[base + 3] = vel_y;
        out[base + 4] = size;
        out[base + 5] = energy;
    }

    Ok(out)
}
